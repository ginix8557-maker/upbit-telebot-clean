import json, os, time, requests
from dotenv import load_dotenv
from telegram import ReplyKeyboardMarkup
from telegram.ext import Updater, MessageHandler, Filters

load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN", "").strip()
CHAT_ID = str(os.getenv("CHAT_ID", "")).strip()
THRESHOLD_PCT = float(os.getenv("THRESHOLD_PCT", "1.0"))

DATA_FILE = "portfolio.json"
UPBIT = "https://api.upbit.com/v1/ticker?markets="

def load_data():
    if not os.path.exists(DATA_FILE):
        return {"coins": {}, "default_threshold_pct": THRESHOLD_PCT}
    with open(DATA_FILE, "r", encoding="utf-8") as f:
        return json.load(f)

def save_data(d):
    with open(DATA_FILE, "w", encoding="utf-8") as f:
        json.dump(d, f, ensure_ascii=False, indent=2)

data = load_data()

def get_price(symbol):
    if "-" not in symbol:
        symbol = "KRW-" + symbol.upper()
    r = requests.get(UPBIT + symbol)
    return float(r.json()[0]["trade_price"])

def format_number(n): return f"{n:,.0f}"

def check_notify(context):
    for sym, info in data["coins"].items():
        try:
            cur = get_price(sym)
        except:
            continue
        base = info.get("last_notified_price", cur)
        th = info.get("threshold_pct", data["default_threshold_pct"])
        if abs(cur/base-1)*100 >= th:
            msg = f"ğŸš¨ {sym} ë³€ë™ {th}% ì´ˆê³¼\nê¸°ì¤€: {format_number(base)} â†’ í˜„ì¬: {format_number(cur)}"
            context.bot.send_message(chat_id=CHAT_ID, text=msg)
            info["last_notified_price"] = cur
            save_data(data)

def message(update, context):
    if CHAT_ID and str(update.effective_chat.id) != CHAT_ID:
        return
    text = update.message.text.strip().replace("  ", " ")
    parts = text.split()
    if not parts: return
    cmd = parts[0].lstrip("/")
    args = parts[1:]
    kb = ReplyKeyboardMarkup([["ìƒíƒœ","ë„ì›€ë§"],["ì¶”ê°€","ì‚­ì œ","ê°€ê²©"],["ì„ê³„ê°’","í‰ë‹¨","ìˆ˜ëŸ‰"]], resize_keyboard=True)
    if cmd in ["ë„ì›€ë§","help"]:
        update.message.reply_text("ëª…ë ¹: ì¶”ê°€, ì‚­ì œ, í‰ë‹¨, ìˆ˜ëŸ‰, ì„ê³„ê°’, ê°€ê²©, ìƒíƒœ", reply_markup=kb)
    elif cmd in ["ìƒíƒœ","show"]:
        text=""
        for sym,info in data["coins"].items():
            cur=get_price(sym)
            avg=info.get("avg_price",0)
            qty=info.get("qty",0)
            text+=f"{sym} / {format_number(avg)} / {qty} / {format_number(cur)}\n"
        update.message.reply_text(text or "ë“±ë¡ëœ ì½”ì¸ ì—†ìŒ", reply_markup=kb)
    elif cmd=="ì¶”ê°€":
        if not args: update.message.reply_text("ì˜ˆ) ì¶”ê°€ BTC", reply_markup=kb); return
        sym="KRW-"+args[0].upper(); data["coins"][sym]={}; save_data(data)
        update.message.reply_text(f"{sym} ì¶”ê°€ë¨", reply_markup=kb)
    elif cmd=="ì‚­ì œ":
        if not args: update.message.reply_text("ì˜ˆ) ì‚­ì œ BTC", reply_markup=kb); return
        sym="KRW-"+args[0].upper()
        data["coins"].pop(sym,None); save_data(data)
        update.message.reply_text(f"{sym} ì‚­ì œë¨", reply_markup=kb)
    elif cmd=="í‰ë‹¨":
        if len(args)<2: update.message.reply_text("ì˜ˆ) í‰ë‹¨ BTC 95000000", reply_markup=kb); return
        sym="KRW-"+args[0].upper()
        data["coins"].setdefault(sym,{})["avg_price"]=float(args[1]); save_data(data)
        update.message.reply_text(f"{sym} í‰ë‹¨ ì„¤ì • ì™„ë£Œ", reply_markup=kb)
    elif cmd=="ìˆ˜ëŸ‰":
        if len(args)<2: update.message.reply_text("ì˜ˆ) ìˆ˜ëŸ‰ BTC 0.1", reply_markup=kb); return
        sym="KRW-"+args[0].upper()
        data["coins"].setdefault(sym,{})["qty"]=float(args[1]); save_data(data)
        update.message.reply_text(f"{sym} ìˆ˜ëŸ‰ ì„¤ì • ì™„ë£Œ", reply_markup=kb)
    elif cmd=="ì„ê³„ê°’":
        if len(args)==1:
            data["default_threshold_pct"]=float(args[0]); save_data(data)
            update.message.reply_text(f"ê¸°ë³¸ ì„ê³„ê°’ {args[0]}%", reply_markup=kb)
        elif len(args)==2:
            sym="KRW-"+args[0].upper()
            data["coins"].setdefault(sym,{})["threshold_pct"]=float(args[1]); save_data(data)
            update.message.reply_text(f"{sym} ê°œë³„ ì„ê³„ê°’ {args[1]}%", reply_markup=kb)
        else:
            update.message.reply_text("ì˜ˆ) ì„ê³„ê°’ 1.0 ë˜ëŠ” ì„ê³„ê°’ BTC 0.5", reply_markup=kb)
    elif cmd=="ê°€ê²©":
        if not args: update.message.reply_text("ì˜ˆ) ê°€ê²© BTC", reply_markup=kb); return
        sym="KRW-"+args[0].upper(); p=get_price(sym)
        update.message.reply_text(f"{sym} í˜„ì¬ê°€ {format_number(p)}ì›", reply_markup=kb)
    else:
        update.message.reply_text("ë„ì›€ë§", reply_markup=kb)

def main():
    if not BOT_TOKEN: print("BOT_TOKEN ëˆ„ë½"); return
    u=Updater(BOT_TOKEN, use_context=True)
    dp=u.dispatcher
    dp.add_handler(MessageHandler(Filters.text & ~Filters.command, message))
    dp.add_handler(MessageHandler(Filters.command, message))
    u.job_queue.run_repeating(check_notify, interval=3, first=5)
    u.start_polling(); u.idle()

if __name__=="__main__":
    main()

